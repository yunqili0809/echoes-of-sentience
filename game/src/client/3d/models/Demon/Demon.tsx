/*
auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import React, { useRef, useState, useEffect } from "react";
import { useFrame } from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";
import {
  AnimationAction,
  AnimationMixer,
  Bone,
  Event,
  Group,
  LoopOnce,
  MeshStandardMaterial,
  MeshToonMaterial,
  SkinnedMesh,
} from "three";
import { hexStringToCode } from "../../../utils/color";
import { setMaterials, setShadows } from "../../../utils/models";
import { GLTF, SkeletonUtils } from "three/examples/jsm/Addons.js";

type GLTFResult = GLTF & {
  nodes: {
    Demon001: SkinnedMesh;
    Body: Bone;
    Head: Bone;
  };
  materials: {
    Texture: MeshStandardMaterial;
  };
};

type ActionName =
  | "Bite_Front"
  | "Bite_InPlace"
  | "Dance"
  | "Death"
  | "HitRecieve"
  | "Idle"
  | "Jump"
  | "No"
  | "Walk"
  | "Yes";

type GLTFActions = Record<ActionName, AnimationAction>;

const lightOrangeIndividualMaterial = new MeshToonMaterial({
  color: hexStringToCode("#630721"),
  // skinning: true,
});
lightOrangeIndividualMaterial.color.convertSRGBToLinear();

export default function Demon({
  isDead,
  lastHit,
  lastAttacked,
  ...props
}: JSX.IntrinsicElements["group"] & {
  isDead: boolean;
  lastHit: number;
  lastAttacked: number;
}) {
  const group = useRef<Group>(null);
  const { nodes, materials, animations, scene } = useGLTF("/Demon.glb");
  const [geometry]: any = useState(() => {
    const clonedScene = SkeletonUtils.clone(scene);
    setMaterials(clonedScene, {
      Texture: lightOrangeIndividualMaterial,
    });
    setShadows(clonedScene);
    return clonedScene;
  });
  const currentAnimationRef = useRef<{
    key: string | null;
    animation: any;
    finished: boolean;
  }>({
    key: null,
    animation: null,
    finished: false,
  });
  const actions = useRef<GLTFActions>();
  const [mixer] = useState(() => new AnimationMixer(nodes.Demon001));
  useFrame((state, delta) => mixer.update(delta));
  useEffect(() => {
    actions.current = {
      Bite_Front: mixer.clipAction(animations[0], group.current),
      Bite_InPlace: mixer.clipAction(animations[1], group.current),
      Dance: mixer.clipAction(animations[2], group.current),
      Death: mixer.clipAction(animations[3], group.current),
      HitRecieve: mixer.clipAction(animations[4], group.current),
      Idle: mixer.clipAction(animations[5], group.current),
      Jump: mixer.clipAction(animations[6], group.current),
      No: mixer.clipAction(animations[7], group.current),
      Walk: mixer.clipAction(animations[8], group.current),
      Yes: mixer.clipAction(animations[9], group.current),
    };
    actions.current.Death.loop = LoopOnce;
    actions.current.Death.clampWhenFinished = true;
    actions.current.HitRecieve.loop = LoopOnce;
    actions.current.HitRecieve.clampWhenFinished = true;
    actions.current.Bite_Front.loop = LoopOnce;
    actions.current.Bite_Front.clampWhenFinished = true;
    return () => animations.forEach((clip) => mixer.uncacheClip(clip));
  }, []);

  useEffect(() => {
    let unsubscribe = () => {};

    const calculateAnimation = () => {
      if (!actions.current) return;

      const currentAnimation = currentAnimationRef.current;

      const duration = 0.2;
      const quickDuration = 0.05;

      const playAnimation = (
        animation: any,
        fadeInDuration: number,
        fadeDuration: number,
        key: string | null
      ) => {
        if (currentAnimation.animation) {
          currentAnimation.animation.fadeOut(fadeDuration);
        } else {
          fadeInDuration = 0;
        }
        animation.reset().setEffectiveWeight(1).fadeIn(fadeInDuration).play();
        currentAnimation.animation = animation;
        currentAnimation.key = key;
        currentAnimation.finished = false;
      };

      const isAttacking = lastAttacked > Date.now() - 100;
      const isHit = lastHit > Date.now() - 100;
      const hitKey = lastHit.toString();
      const attackKey = lastAttacked.toString();

      const processAnimation = (key: string, animation: any) => {
        if (!actions.current) return;

        if (currentAnimation.animation && currentAnimation.key === key) {
        } else {
          playAnimation(animation, quickDuration, quickDuration, key);
        }

        const onFinished = (event: any) => {
          mixer.removeEventListener("finished", onFinished);
          if (actions.current && event.action === animation) {
            currentAnimation.finished = true;
            calculateAnimation();
          }
        };

        mixer.addEventListener("finished", onFinished);

        unsubscribe = () => {
          mixer.removeEventListener("finished", onFinished);
        };
      };

      if (isDead) {
        playAnimation(actions.current.Death, duration, duration, null);
      } else if (
        isAttacking ||
        (currentAnimation.key === attackKey && !currentAnimation.finished)
      ) {
        processAnimation(attackKey, actions.current.Bite_Front);
      } else if (
        isHit ||
        (currentAnimation.key === hitKey && !currentAnimation.finished)
      ) {
        processAnimation(hitKey, actions.current.HitRecieve);
      } else {
        playAnimation(actions.current.Dance, duration, duration, null);
      }
    };

    calculateAnimation();

    return () => {
      unsubscribe();
    };
  }, [isDead, lastHit, lastAttacked]);

  return (
    <group ref={group} {...props} dispose={null}>
      <primitive object={geometry} dispose={null} />
    </group>
  );
}

useGLTF.preload("/Demon.glb");
